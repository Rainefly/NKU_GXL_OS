# OSlab5--by：於一帆，林正青，吴昌昊

实验2/3完成了物理和虚拟内存管理，这给创建内核线程（内核线程是一种特殊的进程）打下了提供内存管理的基础。当一个程序加载到内存中运行时，首先通过ucore OS的内存管理子系统分配合适的空间，然后就需要考虑如何分时使用CPU来“并发”执行多个程序，让每个运行的程序（这里用线程或进程表示）“感到”它们各自拥有“自己”的CPU。 

本次实验将首先接触的是内核线程的管理。内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：

- 内核线程只运行在内核态，用户进程会在在用户态和内核态交替运行
- 所有内核线程共用ucore内核内存空间，不需为每个内核线程维护单独的内存空间，而用户进程需要维护各自的用户内存空间

## 练习0：经典合并代码

## 练习1：分配并初始化一个进程控制块（需要编码）

> alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结 构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
>
> 在alloc_proc函数的实现中，需要初始化的proc_struct结构中的成员变量至少包括以下内容：
>
> state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name
>
> 请说明proc_struct中struct context context 和 struct trapframe *tf 成员变量含义和在本实验中的作用是啥？

## 练习2：为新创建的内核线程分配资源（需要编程）

> 创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成 具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资 源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的 一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的 do_fork函数中的处理过程。它的大致执行步骤包括：
>
> - 调用alloc_proc，首先获得一块用户信息块。
> - 为进程分配一个内核栈。 
> - 复制原进程的内存管理信息到新进程（但内核线程不必做此事） 
> - 复制原进程上下文到新进程 
> - 将新进程添加到进程列表 
> - 唤醒新进程 
> - 返回新进程号
>
> 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由

## 练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成 进程切换的。（无编码工作）

> 请在实验报告中简要说明你对proc_run函数的分析。并回答如下问题： 
>
> - 在本实验的执行过程中，创建且运行了几个内核线程？ 
> - 语句 local_intr_save(intr_flag);....local_intr_restore(intr_flag); 在这里有何作用?请 说明理由 
>
> 完成代码编写后，编译并运行代码：make qemu 
>
> 如果可以得到如 附录A所示的显示内容（仅供参考，不是标准答案输出），则基本正确。

## Challenge：实现支持任意大小的内存分配算法

> 这不是本实验的内容，其实是上一次实验内存的扩展，但考虑到现在的slab算法比较复杂，有 必要实现一个比较简单的任意大小内存分配算法。可参考本实验中的slab如何调用基于页的内 存分配算法（注意，不是要你关注slab的具体实现）来实现first-fit/best-fit/worst-fit/buddy等支 持任意大小的内存分配算法。